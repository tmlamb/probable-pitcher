"use client";

import { useState } from "react";
import { TZDate } from "@date-fns/tz";
import { MinusCircledIcon, PlusCircledIcon } from "@radix-ui/react-icons";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import type { PitcherSubscription } from "@probable/ui/utils";
import { cn } from "@probable/ui";
import { Button } from "@probable/ui/button";
import { Input } from "@probable/ui/input";

import { useTRPC } from "~/trpc/react";

export default function PitcherSearch() {
  const trpc = useTRPC();
  const [searchFilter, setSearchFilter] = useState<string>();

  const queryClient = useQueryClient();

  const searchQuery = useQuery(
    trpc.pitcher.byFuzzyName.queryOptions(searchFilter ?? "", {
      enabled: !!searchFilter,
    }),
  );

  const subscriptionQuery = useQuery(
    trpc.subscription.byUserId.queryOptions(undefined, {
      enabled: !!searchFilter,
    }),
  );

  if (searchQuery.isError) {
    console.error(
      `Error fuzzy searching for pitchers on homepage: ${JSON.stringify(searchQuery.error)}`,
    );
  }

  const pitchers = searchQuery.data?.map((pitcher) => ({
    ...pitcher,
    subscription:
      subscriptionQuery.data?.find((sub) => sub.pitcherId === pitcher.id) ??
      undefined,
  }));

  const subscribeMutation = useMutation(
    trpc.subscription.create.mutationOptions({
      scope: { id: "subscription" },
      onMutate: async ({ pitcherId }) => {
        await queryClient.cancelQueries(
          trpc.subscription.byUserId.pathFilter(),
        );
        const previousSubscriptions = queryClient.getQueryData(
          trpc.subscription.byUserId.queryKey(),
        );
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          (old) => {
            if (old) {
              const pitcher = pitchers?.find((p) => p.id === pitcherId);
              if (pitcher) {
                return [
                  ...old,
                  // Optimistically add a new subscription with some dummy data.
                  // This dummy data will be replaced with ids generated by the
                  // database once the mutation completes.
                  {
                    id: String(new Date().valueOf()),
                    enabled: true,
                    pitcherId: pitcher.id,
                    userId: "",
                    pitcher: {
                      id: pitcher.id,
                      name: pitcher.name,
                      teamId: pitcher.teamId,
                      homeGames: pitcher.subscription?.pitcher.homeGames ?? [],
                      awayGames: pitcher.subscription?.pitcher.awayGames ?? [],
                      number: pitcher.number,
                      team: {
                        name: "",
                        id: "",
                        abbreviation: "",
                      },
                    },
                  },
                ];
              }
            }
          },
        );
        return { previousSubscriptions };
      },
      onError: (err, _, context) => {
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          context?.previousSubscriptions,
        );
        console.error("Error updating subscription", err);
      },
      onSettled: () => {
        queryClient
          .invalidateQueries(trpc.subscription.byUserId.pathFilter())
          .catch(console.error);
        queryClient
          .invalidateQueries(trpc.pitcher.byFuzzyName.pathFilter())
          .catch(console.error);
      },
    }),
  );

  const unsubscribeMutation = useMutation(
    trpc.subscription.delete.mutationOptions({
      scope: { id: "subscription" },
      onMutate: async ({ subscriptionId }) => {
        await queryClient.cancelQueries(
          trpc.subscription.byUserId.pathFilter(),
        );
        const previousSubscriptions = queryClient.getQueryData(
          trpc.subscription.byUserId.queryKey(),
        );
        queryClient.setQueryData(trpc.subscription.byUserId.queryKey(), (old) =>
          old?.filter((s) => s.id !== subscriptionId),
        );
        return { previousSubscriptions };
      },
      onError: (err, _, context) => {
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          context?.previousSubscriptions,
        );
        console.error("Error removing subscription", err);
      },
      onSettled: () => {
        queryClient
          .invalidateQueries(trpc.subscription.byUserId.pathFilter())
          .catch(console.error);
        queryClient
          .invalidateQueries(trpc.pitcher.byFuzzyName.pathFilter())
          .catch(console.error);
      },
    }),
  );

  const subscribedAndAvailablePitchers: (string | PitcherSubscription)[] = [];

  const subscribedPitchers = pitchers
    ?.filter((p) => p.subscription)
    .map((p) => ({
      ...p,
      team: {
        abbreviation: p.teamAbbreviation ?? null,
      },
    }));
  if (subscribedPitchers?.length) {
    subscribedAndAvailablePitchers.push("Subscribed");
    subscribedAndAvailablePitchers.push(...subscribedPitchers);
  }

  if (searchFilter) {
    const availablePitchers = pitchers
      ?.filter((p) => !p.subscription)
      .map((p) => ({
        ...p,
        team: {
          abbreviation: p.teamAbbreviation ?? null,
        },
      }));
    if (availablePitchers?.length) {
      subscribedAndAvailablePitchers.push("Available");
      subscribedAndAvailablePitchers.push(...availablePitchers);
    }
  }

  const pauseMutations =
    subscribeMutation.isPending ||
    unsubscribeMutation.isPending ||
    searchQuery.isFetching ||
    (!searchQuery.isSuccess && !!searchFilter) ||
    subscriptionQuery.isFetching;

  return (
    <div className="bg-accent z-10 m-3 flex flex-col gap-3">
      <Input
        className="bg-background border-primary"
        placeholder="Search for a pitcher"
        onChange={(e) => setSearchFilter(e.target.value)}
      />
      <div className="max-w-96">
        {subscribedAndAvailablePitchers.map((pitcher) => {
          if (typeof pitcher === "string") {
            return (
              <h2
                key={pitcher}
                className="text-muted-foreground mt-3 text-left text-xs tracking-wider uppercase"
              >
                {pitcher}
              </h2>
            );
          }
          return (
            <PitcherCard
              key={pitcher.id}
              pitcher={pitcher}
              subscribeHandler={() =>
                subscribeMutation.mutate({
                  // TODO correctly type this
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  pitcherId: pitcher.id!,
                })
              }
              unsubscribeHandler={() =>
                unsubscribeMutation.mutate({
                  subscriptionId: pitcher.subscription?.id ?? "",
                })
              }
              disabled={pauseMutations}
            />
          );
        })}
      </div>
    </div>
  );
}

const PitcherCard = ({
  subscribeHandler,
  unsubscribeHandler,
  pitcher,
  disabled,
  className,
}: {
  subscribeHandler: () => void;
  unsubscribeHandler?: () => void;
  pitcher: PitcherSubscription;
  disabled?: boolean;
  className?: string;
}) => {
  return (
    <div className={cn("relative flex flex-row items-center", className)}>
      {pitcher.subscription && unsubscribeHandler && (
        <Button
          className="-my-3 -ml-3 p-3"
          variant="none"
          size="icon"
          onClick={unsubscribeHandler}
          disabled={disabled}
        >
          <div>
            <MinusCircledIcon className="text-destructive" />
          </div>
        </Button>
      )}
      <div className="flex-1 flex-row items-center justify-between">
        <div className={cn("border-muted flex flex-row items-center gap-1.5")}>
          <p className="p-[.425rem]">{pitcher.name}</p>
          <div className="text-muted-foreground flex flex-col items-center text-xs">
            <p className="">{pitcher.number}</p>
            <p className="">{pitcher.team.abbreviation}</p>
          </div>
        </div>

        {pitcher.nextGameDate && !unsubscribeHandler && (
          <div>
            <span className="text-muted-foreground ml-1.5 text-sm">
              {new TZDate(
                pitcher.nextGameDate,
                Intl.DateTimeFormat().resolvedOptions().timeZone ||
                  "America/New_York",
              ).toLocaleTimeString([], {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
              })}
            </span>
          </div>
        )}
      </div>
      {!pitcher.subscription && (
        <Button
          className="-my-3 -ml-3 p-3"
          variant="none"
          size="icon"
          onClick={subscribeHandler}
          disabled={disabled}
        >
          <div>
            <PlusCircledIcon className="text-primary" />
          </div>
        </Button>
      )}
    </div>
  );
};
