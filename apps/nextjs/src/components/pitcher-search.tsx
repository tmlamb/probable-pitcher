"use client";

import { useState } from "react";
import { MinusCircledIcon, PlusCircledIcon } from "@radix-ui/react-icons";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import { formatInTimeZone } from "date-fns-tz";

import * as ui from "@probable/ui";
import { Button } from "@probable/ui/button";

import { useTRPC } from "~/trpc/react";

export default function PitcherSearch() {
  const trpc = useTRPC();
  const [searchFilter, setSearchFilter] = useState<string>();

  const queryClient = useQueryClient();

  const searchQuery = useQuery(
    trpc.pitcher.byFuzzyName.queryOptions(searchFilter ?? "", {
      enabled: !!searchFilter,
    }),
  );

  const subscriptionQuery = useSuspenseQuery(
    trpc.subscription.byUserId.queryOptions(),
  );

  if (searchQuery.isError) {
    console.error(
      `Error fuzzy searching for pitchers on homepage: ${JSON.stringify(searchQuery.error)}`,
    );
  }

  const pitchers = searchQuery.data?.map((pitcher) => ({
    ...pitcher,
    subscription:
      subscriptionQuery.data.find((sub) => sub.pitcherId === pitcher.id) ??
      undefined,
  }));

  const subscribeMutation = useMutation(
    trpc.subscription.create.mutationOptions({
      scope: { id: "subscription" },
      onMutate: async ({ pitcherId }) => {
        await queryClient.cancelQueries(
          trpc.subscription.byUserId.pathFilter(),
        );
        const previousSubscriptions = queryClient.getQueryData(
          trpc.subscription.byUserId.queryKey(),
        );
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          (old) => {
            if (old) {
              const pitcher = pitchers?.find((p) => p.id === pitcherId);
              if (pitcher) {
                return [
                  ...old,
                  // Optimistically add a new subscription with some dummy data.
                  // This dummy data will be replaced with ids generated by the
                  // database once the mutation completes.
                  {
                    id: String(new Date().valueOf()),
                    enabled: true,
                    pitcherId: pitcher.id,
                    userId: "",
                    pitcher: {
                      id: pitcher.id,
                      name: pitcher.name,
                      teamId: pitcher.teamId,
                      homeGames: pitcher.subscription?.pitcher.homeGames ?? [],
                      awayGames: pitcher.subscription?.pitcher.awayGames ?? [],
                      number: pitcher.number,
                      team: {
                        name: "",
                        id: "",
                        abbreviation: "",
                      },
                    },
                  },
                ];
              }
            }
          },
        );
        return { previousSubscriptions };
      },
      onError: (err, _, context) => {
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          context?.previousSubscriptions,
        );
        console.error("Error updating subscription", err);
      },
      onSettled: () => {
        queryClient
          .invalidateQueries(trpc.subscription.byUserId.pathFilter())
          .catch(console.error);
        queryClient
          .invalidateQueries(trpc.pitcher.byFuzzyName.pathFilter())
          .catch(console.error);
      },
    }),
  );

  const unsubscribeMutation = useMutation(
    trpc.subscription.delete.mutationOptions({
      scope: { id: "subscription" },
      onMutate: async ({ subscriptionId }) => {
        await queryClient.cancelQueries(
          trpc.subscription.byUserId.pathFilter(),
        );
        const previousSubscriptions = queryClient.getQueryData(
          trpc.subscription.byUserId.queryKey(),
        );
        queryClient.setQueryData(trpc.subscription.byUserId.queryKey(), (old) =>
          old?.filter((s) => s.id !== subscriptionId),
        );
        return { previousSubscriptions };
      },
      onError: (err, _, context) => {
        queryClient.setQueryData(
          trpc.subscription.byUserId.queryKey(),
          context?.previousSubscriptions,
        );
        console.error("Error removing subscription", err);
      },
      onSettled: () => {
        queryClient
          .invalidateQueries(trpc.subscription.byUserId.pathFilter())
          .catch(console.error);
        queryClient
          .invalidateQueries(trpc.pitcher.byFuzzyName.pathFilter())
          .catch(console.error);
      },
    }),
  );

  const subscribedAndAvailablePitchers: (string | ui.PitcherSubscription)[] =
    [];

  const subscribedPitchers = pitchers
    ?.filter((p) => p.subscription)
    .map((p) => ({
      ...p,
      team: {
        abbreviation: p.teamAbbreviation ?? null,
      },
    }));
  if (subscribedPitchers?.length) {
    subscribedAndAvailablePitchers.push("Subscribed");
    subscribedAndAvailablePitchers.push(...subscribedPitchers);
  }

  if (searchFilter) {
    const availablePitchers = pitchers
      ?.filter((p) => !p.subscription)
      .map((p) => ({
        ...p,
        team: {
          abbreviation: p.teamAbbreviation ?? null,
        },
      }));
    if (availablePitchers?.length) {
      subscribedAndAvailablePitchers.push("Available");
      subscribedAndAvailablePitchers.push(...availablePitchers);
    }
  }

  const pauseMutations =
    subscribeMutation.isPending ||
    unsubscribeMutation.isPending ||
    searchQuery.isFetching ||
    (!searchQuery.isSuccess && !!searchFilter) ||
    subscriptionQuery.isFetching;

  return (
    <div>
      <input onChange={(e) => setSearchFilter(e.target.value)} />
      <div>
        {subscribedAndAvailablePitchers.map((pitcher, index) => {
          if (typeof pitcher === "string") {
            return (
              <h2 key={index} className="text-lg font-bold">
                {pitcher}
              </h2>
            );
          }
          return (
            <PitcherCard
              key={pitcher.id}
              pitcher={pitcher}
              subscribeHandler={() =>
                subscribeMutation.mutate({
                  // TODO correctly type this
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  pitcherId: pitcher.id!,
                })
              }
              unsubscribeHandler={() =>
                unsubscribeMutation.mutate({
                  subscriptionId: pitcher.subscription?.id ?? "",
                })
              }
              disabled={pauseMutations}
            />
          );
        })}
      </div>
    </div>
  );
}

const PitcherCard = ({
  subscribeHandler,
  unsubscribeHandler,
  pitcher,
  disabled,
  className,
}: {
  subscribeHandler: () => void;
  unsubscribeHandler?: () => void;
  pitcher: ui.PitcherSubscription;
  disabled?: boolean;
  className?: string;
}) => {
  return (
    <div>
      <div className={ui.cn("relative", className)}>
        {pitcher.subscription && unsubscribeHandler && (
          <div>
            <Button
              className="-my-3 -ml-3 p-3"
              variant="primary"
              size="icon"
              onClick={unsubscribeHandler}
              disabled={disabled}
            >
              <div>
                <MinusCircledIcon className="text-destructive" />
              </div>
            </Button>
          </div>
        )}
        <div className="flex-1 flex-row items-center justify-between">
          <div className="flex-row items-center">
            <span>{pitcher.name}</span>
            <div className="-my-1.5 mx-3 items-center">
              {pitcher.number && (
                <span className="text-muted-foreground -mb-0.5 text-xs">
                  {pitcher.number}
                </span>
              )}
              <span className="text-muted-foreground text-xs">
                {pitcher.team.abbreviation}
              </span>
            </div>
          </div>
          {pitcher.nextGameDate && !unsubscribeHandler && (
            <div>
              <span className="text-muted-foreground ml-1.5 text-sm">
                {formatInTimeZone(
                  pitcher.nextGameDate,
                  Intl.DateTimeFormat().resolvedOptions().timeZone ||
                    "America/New_York",
                  "h:mmaaaaa",
                )}
              </span>
            </div>
          )}
        </div>
        {!pitcher.subscription && (
          <Button
            className="absolute right-0 -m-3 items-end p-3"
            onClick={subscribeHandler}
            disabled={disabled}
          >
            <div>
              <PlusCircledIcon className="text-primary" />
            </div>
          </Button>
        )}
      </div>
    </div>
  );
};
